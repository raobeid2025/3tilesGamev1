// Tile data structure
export interface Tile {
  id: number;
  emoji: string;
  isMatched: boolean;
  isInSlot?: boolean;
  layer: number;
  position: { row: number; col: number };
  pattern: 'X' | 'square' | 'diamond' | 'plus' | 'circle';
}

// Game status types
export type GameStatus = "playing" | "won" | "lost" | "level-complete";

// Emoji themes
export type EmojiTheme = "animals" | "food" | "objects" | "faces" | "mixed";

export const emojiThemes: Record<EmojiTheme, string[]> = {
  animals: ["ðŸ¶", "ðŸ±", "ðŸ­", "ðŸ¹", "ðŸ°", "ðŸ¦Š", "ðŸ»", "ðŸ¼", "ðŸ¨", "ðŸ¦", "ðŸ®", "ðŸ·"],
  food: ["ðŸŽ", "ðŸ•", "ðŸ”", "ðŸŸ", "ðŸ¥", "ðŸ‡", "ðŸ‰", "ðŸ“", "ðŸ’", "ðŸ‘", "ðŸ", "ðŸ¥¥"],
  objects: ["âš½", "ðŸ€", "ðŸˆ", "âš¾", "ðŸŽ¾", "ðŸ", "ðŸŽ±", "ðŸ“", "ðŸ¸", "ðŸ¥", "ðŸŽ®", "ðŸŽ¯"],
  faces: ["ðŸ˜€", "ðŸ˜‚", "ðŸ¥°", "ðŸ˜Ž", "ðŸ¤©", "ðŸ˜", "ðŸ¤—", "ðŸ¤‘", "ðŸ¤ ", "ðŸ¥³", "ðŸ˜œ", "ðŸ¤ª"],
  mixed: ["ðŸ¶", "ðŸ•", "âš½", "ðŸ˜€", "ðŸ±", "ðŸ”", "ðŸ€", "ðŸ˜‚", "ðŸ­", "ðŸŽ", "ðŸˆ", "ðŸ¥°"]
};

export interface LevelConfig {
  id: number;
  name: string;
  gridSize: number;
  layers: number;
  emojisNeeded: number;
  slotSize: number;
  totalTiles: number;
  pattern: 'X' | 'square' | 'diamond' | 'plus' | 'circle';
}

// Generate levels with geometric patterns
export const generateLevels = (): LevelConfig[] => {
  const levels: LevelConfig[] = [];
  const allPatterns: ('X' | 'square' | 'diamond' | 'plus' | 'circle')[] = ['X', 'square', 'diamond', 'plus', 'circle'];
  let patternIndex = 0;

  const getNextPattern = () => {
    const pattern = allPatterns[patternIndex % allPatterns.length];
    patternIndex++;
    return pattern;
  };
  
  for (let i = 1; i <= 50; i++) {
    let gridSize: number;
    let layers: number;
    let pattern: 'X' | 'square' | 'diamond' | 'plus' | 'circle';
    const slotSize = 7; // Keep slot size consistent

    if (i <= 4) { // Levels 1-4: Single Layer Intro
      gridSize = 6;
      layers = 1;
      pattern = getNextPattern(); // Cycle through patterns
    } else if (i <= 10) { // Levels 5-10: Two Layers Intro
      gridSize = 7;
      layers = 2;
      pattern = getNextPattern();
    } else if (i <= 20) { // Levels 11-20: More Two Layers
      gridSize = 8;
      layers = 2;
      pattern = getNextPattern();
    } else if (i <= 30) { // Levels 21-30: Three Layers Intro
      gridSize = 9;
      layers = 3;
      pattern = getNextPattern();
    } else if (i <= 40) { // Levels 31-40: More Three Layers
      gridSize = 10;
      layers = 3;
      pattern = getNextPattern();
    } else { // Levels 41-50: Four Layers Challenge
      gridSize = 11;
      layers = 4;
      pattern = getNextPattern();
    }

    // Determine if the pattern should be filled based on layers
    const isFilledPattern = layers > 1;
    const patternPositions = generatePatternPositions(pattern, gridSize, isFilledPattern);
    
    // Calculate totalTiles based on the number of positions generated by the pattern
    // Ensure totalTiles is a multiple of 3 and doesn't exceed available spots * layers
    let calculatedTotalTiles = patternPositions.length * layers;
    // We need to ensure we have enough tiles to make the game challenging but solvable.
    // Let's aim for a minimum number of unique emoji types.
    let minEmojisNeeded = 4; // Start with at least 4 unique emojis (12 tiles)
    if (layers === 2) minEmojisNeeded = 8; // 24 tiles
    if (layers === 3) minEmojisNeeded = 12; // 36 tiles
    if (layers === 4) minEmojisNeeded = 15; // 45 tiles

    let totalTiles = Math.max(minEmojisNeeded * 3, Math.floor(calculatedTotalTiles / 3) * 3);
    // Ensure totalTiles doesn't exceed the actual number of available spots * layers
    totalTiles = Math.min(totalTiles, patternPositions.length * layers);
    // And ensure it's still a multiple of 3
    totalTiles = Math.floor(totalTiles / 3) * 3;

    const emojisNeeded = totalTiles / 3;

    levels.push({
      id: i,
      name: `Level ${i}`,
      gridSize,
      layers,
      emojisNeeded,
      slotSize,
      totalTiles,
      pattern
    });
  }
  
  return levels;
};

export const levelConfigs: LevelConfig[] = generateLevels();

// Pattern position generators
export const generatePatternPositions = (pattern: string, gridSize: number, isFilled: boolean) => {
  const positions: { row: number; col: number }[] = [];
  
  if (isFilled) {
    switch (pattern) {
      case 'X': // Filled X (like a diamond)
      case 'diamond': // Already a filled diamond
        const center = Math.floor(gridSize / 2);
        for (let i = 0; i < gridSize; i++) {
          const distance = Math.abs(i - center);
          for (let j = distance; j < gridSize - distance; j++) {
            positions.push({ row: i, col: j });
          }
        }
        break;
      case 'square': // Filled square
        for (let r = 0; r < gridSize; r++) {
          for (let c = 0; c < gridSize; c++) {
            positions.push({ row: r, col: c });
          }
        }
        break;
      case 'plus': // Filled plus (a solid cross)
        const mid = Math.floor(gridSize / 2);
        for (let r = 0; r < gridSize; r++) {
          for (let c = 0; c < gridSize; c++) {
            if (r === mid || c === mid) {
              positions.push({ row: r, col: c });
            }
          }
        }
        break;
      case 'circle': // Filled circle (approximate)
        const radius = gridSize / 2;
        const centerX = (gridSize - 1) / 2; // Center of the grid
        const centerY = (gridSize - 1) / 2;
        for (let r = 0; r < gridSize; r++) {
          for (let c = 0; c < gridSize; c++) {
            const dist = Math.sqrt(Math.pow(r - centerX, 2) + Math.pow(c - centerY, 2));
            if (dist <= radius + 0.5) { // Add a small buffer for approximation
              positions.push({ row: r, col: c });
            }
          }
        }
        break;
    }
  } else { // Original (sparse) patterns for single layer
    switch (pattern) {
      case 'X':
        for (let i = 0; i < gridSize; i++) {
          positions.push({ row: i, col: i });
          if (i !== gridSize - 1 - i) {
            positions.push({ row: i, col: gridSize - 1 - i });
          }
        }
        break;
      case 'square':
        for (let i = 0; i < gridSize; i++) {
          positions.push({ row: 0, col: i }); // Top row
          positions.push({ row: gridSize - 1, col: i }); // Bottom row
          positions.push({ row: i, col: 0 }); // Left column
          positions.push({ row: i, col: gridSize - 1 }); // Right column
        }
        break;
      case 'diamond': // This was already a filled diamond, so it's fine here too
        const center = Math.floor(gridSize / 2);
        for (let i = 0; i < gridSize; i++) {
          const distance = Math.abs(i - center);
          for (let j = distance; j < gridSize - distance; j++) {
            positions.push({ row: i, col: j });
          }
        }
        break;
      case 'plus':
        const mid = Math.floor(gridSize / 2);
        for (let i = 0; i < gridSize; i++) {
          positions.push({ row: mid, col: i }); // Horizontal line
          positions.push({ row: i, col: mid }); // Vertical line
        }
        break;
      case 'circle':
        // Circle-like pattern (corners and midpoints)
        positions.push({ row: 0, col: 0 }); // Top-left
        positions.push({ row: 0, col: gridSize - 1 }); // Top-right
        positions.push({ row: gridSize - 1, col: 0 }); // Bottom-left
        positions.push({ row: gridSize - 1, col: gridSize - 1 }); // Bottom-right
        positions.push({ row: 0, col: Math.floor(gridSize / 2) }); // Top-center
        positions.push({ row: gridSize - 1, col: Math.floor(gridSize / 2) }); // Bottom-center
        positions.push({ row: Math.floor(gridSize / 2), col: 0 }); // Left-center
        positions.push({ row: Math.floor(gridSize / 2), col: gridSize - 1 }); // Right-center
        break;
    }
  }
  // Remove duplicates for all cases
  return positions.filter((pos, index, self) => 
    index === self.findIndex(p => p.row === pos.row && p.col === pos.col)
  );
};